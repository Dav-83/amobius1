<!DOCTYPE html>
<html>
<head>
<link href="screen.css" media="all" rel="stylesheet" type="text/css"/>

</head>
<body onload="startGame()">
<h1>Amobius - Fuel Up and Ship Out!</h1>
<div class="gameCon">
<canvas id="myCanvas" width="700" height="600" style="border:1px solid #990012;"> 
Your browser does not support the HTML5 canvas tag.</canvas>
</div>
<script>
var WIDTH = 700;
var HEIGHT = 600;
var FPS = 20;

//************************Custom shapes that rotate and move on a point by point basis*******************
//***********That is according to a target and pivot point the vertices of each shape are moved***************
function Triang(p1x, p1y, p2x, p2y, p3x, p3y, outlineColour, fillColour, lineWidth){
	var aX = p1x;
	var aY = p1y;
	var bX = p2x;
	var bY = p2y;
	var cX = p3x;
	var cY = p3y;
	var relPoints = [aX, aY, bX, bY, cX, cY];
	var olC = outlineColour;
	var fC = fillColour;
	var lW = lineWidth;
	this.truePoints = [];
	
	this.update = function(pivX, pivY, targX, targY){
		var pX;
		var pY;
		var run = targX - pivX;
		var rise = pivY - targY;
		var hyp = Math.sqrt(rise * rise + run * run);
		this.truePoints = [];
		
		for(i = 0; i < relPoints.length; i += 2){
				pX = pivX + (relPoints[i + 1] / hyp * run + relPoints[i] / hyp * rise);
				pY = pivY - (relPoints[i + 1] / hyp * rise - relPoints[i] / hyp * run);
				this.truePoints.push(pX, pY);
		}
	}
	
	this.draw = function(){
		var ctx = myGameArea.context;
		
		ctx.beginPath();	
		ctx.moveTo(this.truePoints[0], this.truePoints[1]);
		ctx.lineTo(this.truePoints[2], this.truePoints[3]);
		ctx.lineTo(this.truePoints[4], this.truePoints[5]);
		ctx.lineTo(this.truePoints[0], this.truePoints[1]);
		ctx.closePath();
		
		ctx.lineWidth = lW;
		ctx.fillStyle = fC;
		ctx.fill();
		ctx.strokeStyle = olC;
		ctx.stroke();
	}

}
	
function Rectang(x, y, w, h, outlineColour, fillColour, lineWidth){
	//points relative to pivot point
	var aX = x;
	var aY = y;
	var bX = x + w;
	var bY = y;
	var cX = bX;
	var cY = y - h;
	var dX = aX;
	var dY = cY;
	var relPoints = [aX, aY, bX, bY, cX, cY, dX, dY];
	var olC = outlineColour;
	var fC = fillColour;
	var lW = lineWidth;
	this.truePoints = [];
	
	this.update = function(pivX, pivY, targX, targY){
		var pX;
		var pY;
		var run = targX - pivX;
		var rise = pivY - targY;
		var hyp = Math.sqrt(rise * rise + run * run);
		this.truePoints = [];

		
		//frontX = pivX + pivDist / hyp * run;
		//frontY = pivY + pivDist / hyp * rise;
		//backX = pivX - pivDist / hyp * run;
		//backY = pivY - pivDist / hyp * rise;
		//leftX = pivX + pivDist / hyp * rise;
		//leftY = pivY + pivDist / hyp * run * -1;
		//rightX = pivX + pivDist / hyp * rise * -1;
		//rightY = pivY + pivDist / hyp * run;
		for(i = 0; i < relPoints.length; i += 2){
				pX = pivX + (relPoints[i + 1] / hyp * run + relPoints[i] / hyp * rise);
				pY = pivY - (relPoints[i + 1] / hyp * rise - relPoints[i] / hyp * run);
				this.truePoints.push(pX, pY);
		}
	}
	
	this.draw = function(){
		var ctx = myGameArea.context;
		
		ctx.beginPath();
		ctx.moveTo(this.truePoints[0], this.truePoints[1]);
		ctx.lineTo(this.truePoints[2], this.truePoints[3]);
		ctx.lineTo(this.truePoints[4], this.truePoints[5]);
		ctx.lineTo(this.truePoints[6], this.truePoints[7]);
		ctx.lineTo(this.truePoints[0], this.truePoints[1]);
		ctx.closePath();
		
		ctx.lineWidth = lW;
		ctx.fillStyle = fC;
		ctx.fill();
		ctx.strokeStyle = olC;
		ctx.stroke();
	}
}

function Quadril(p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y, outlineColour, fillColour, lineWidth){
	var aX = p1x;
	var aY = p1y;
	var bX = p2x;
	var bY = p2y;
	var cX = p3x;
	var cY = p3y;
	var dX = p4x;
	var dY = p4y;
	var relPoints = [aX, aY, bX, bY, cX, cY, dX, dY];
	var olC = outlineColour;
	var fC = fillColour;
	var lW = lineWidth;
	this.truePoints = [];
	
	this.update = function(pivX, pivY, targX, targY){
		var pX;
		var pY;
		var run = targX - pivX;
		var rise = pivY - targY;
		var hyp = Math.sqrt(rise * rise + run * run);
		this.truePoints = [];
		
		for(i = 0; i < relPoints.length; i += 2){
				pX = pivX + (relPoints[i + 1] / hyp * run + relPoints[i] / hyp * rise);
				pY = pivY - (relPoints[i + 1] / hyp * rise - relPoints[i] / hyp * run);
				this.truePoints.push(pX, pY);
		}
	}
	
	this.draw = function(){
		var ctx = myGameArea.context;
		
		ctx.beginPath();	
		ctx.moveTo(this.truePoints[0], this.truePoints[1]);
		ctx.lineTo(this.truePoints[2], this.truePoints[3]);
		ctx.lineTo(this.truePoints[4], this.truePoints[5]);
		ctx.lineTo(this.truePoints[6], this.truePoints[7]);
		ctx.lineTo(this.truePoints[0], this.truePoints[1]);
		ctx.closePath();
		
		ctx.lineWidth = lW;
		ctx.fillStyle = fC;
		ctx.fill();
		ctx.strokeStyle = olC;
		ctx.stroke();
	}
}
function Oval(centreX, centreY, width, height){
	
}
	
	
//**********************A simple cannon made up of moving rotating shapes*********************
function Cannon(x, y){
	var pivX = x;
	var pivY = y;
	var crosshairX = x;
	var crosshairY = 0;
	var crosshairS= 3;
	var bulletX = pivX;
	var bulletY = pivY;
	
	
	var chamber = new Rectang(-5, 20, 10, 30, "black", "grey", 4);
	var barrel = new Rectang(-2.5, 60, 5, 40, "black", "grey", 2);
	var flankR = new Triang(5, 10, 10, -8, 5, -12, "black", "blue", 2);
	var flankL = new Triang(-5, 10, -10, -8, -5, -12, "black", "blue", 2);
	var noz = new Quadril(-4, 60, 4, 60, 2, 65, -2, 65, "black", "blue", 2);
	var lbeam = new Rectang(-2.5, 5, 5, 10, "blue", "white", 2);
	
	this.update = function(pX, pY, tX, tY, speed){
		var run = tX - crosshairX;
		var rise = tY - crosshairY;
		var dist = Math.sqrt(rise * rise + run * run);
		var unitX = run / dist;
		var unitY = rise / dist;
		
		//if target is within the crosshair stop moving crosshair and fire beam/bullet
		if(tX > crosshairX - crosshairS && tX < crosshairX + crosshairS 
		&& tY > crosshairY - crosshairS && tY < crosshairY + crosshairS){
			chamber.update(pivX, pivY, crosshairX, crosshairY);
			barrel.update(pivX, pivY, crosshairX, crosshairY);
			
			bulletX += unitX * speed;
			bulletY += unitY * speed;
			lbeam.update(bulletX, bulletY, crosshairX, crosshairY);
		}
		else{
			
			crosshairX += unitX * speed;
			crosshairY += unitY * speed;
		
			chamber.update(pivX, pivY, crosshairX, crosshairY);
			barrel.update(pivX, pivY, crosshairX, crosshairY);
			flankR.update(pivX, pivY, crosshairX, crosshairY);
			flankL.update(pivX, pivY, crosshairX, crosshairY);
			noz.update(pivX, pivY, crosshairX, crosshairY);
		}
	}
	
	this.draw = function(){
		var ctx = myGameArea.context;
		ctx.beginPath();
		ctx.arc(crosshairX, crosshairY, 5, 0, 2 * Math.PI);
		ctx.stroke();
		
		lbeam.draw();
		chamber.draw();
		barrel.draw();
		flankR.draw();
		flankL.draw();
		noz.draw();
	}
}
	
var myGameArea = {
	canvas : document.getElementById("myCanvas"),
	start : function() {
		//context for myGameArea is given the canvas context 2d object complete with methods
		this.context = this.canvas.getContext("2d");
		//insert canvas before the first child node of html body
		//document.body.insertBefore(this.canvas, document.body.childNodes[2]);
		this.interval = setInterval(updateGameArea, FPS);
			
	},
	clear : function() {
		this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
	}
}
 
var gun1 = new Cannon(350, 300);

function updateGameArea(){
		//clear canvas before updating frame
		myGameArea.clear();
		
		gun1.update(350, 300, 355, 500, 1);
		gun1.draw()
		
}

function startGame() {
	myGameArea.start();
}
	
	

</script>

</body>
</html>